= Code: Who, What, Why, Where, When
Jez Higgins, jez@jezuk.co.uk
{docdate}
:notitle:
:customcss: style/theme-tweak.css
:revealjs_theme: white
:revealjs_progress: false

== !

[big]*CODE*

*Who, What, Why, Where, When* +


_Jez Higgins_

ACCU 101: Early Career Day

[NOTE.speaker]
--
Hello again friends, I'm Jez and I'm here to talk with you about code.

* Who it's for
* What it's for
* Why we write it
* Where we should focus our attention
* And honestly, I thought of what seemed like a snappy title, then had to backfill in the abstract to make the title work.

I want us to think about code in the large and in the small, and along the way we'll be addressing the key questions of tabs vs spaces, emacs vs vi, and whether Thor is stronger than the Hulk.

No, of course, we won't, because those things are insoluable and, whisper it, unimportant. There are so many insoluable important things we could be thinking about instead.

If you were to say to me, write us some code, right now, this minute, then sure I can write you some code. And if I said the same to you, could you, all of you here, write some code right now, you'd all say yes, right?
--

== !

[big]*Code is easy*

[NOTE.speaker]
--
Writing code is easy, right?

Yes?

Yes!

Because it's easy, right? We all know how to write code, probably in more than one language, perhaps in quite a few.

But if I did say to you "write me some code", what would you immediately ask of me?
--

== !

[big]*What should I write?*

[NOTE.speaker]
--
Excellent question.

Excellent.

This is the key question that we, all of us here, as professional programmers, all of us in the wider programming community, should be asking.

What should I write?
--

== !

[big]*Code is hard*

[NOTE.speaker]
--
When we write code, we taking stuff that we just think up - it comes from inside us  - and communicate that as directly as we can into the computer.  And, after a little bit of practice, that's an easy process.

But the very same things that make writing code easy is what makes writing it hard.

We can imagine what we want, but expressing it code can be difficult. Often the solution to that difficulty feels like it should be writing more code.

If we just do this, then that'll be ok, ah, except February only has 28 days. Except in an Olympic year, but not 2021 ...

Because code is easy, we can write code all day. And we all know where this is going.
--

== !

[big]*Code is for everyone*

[NOTE.speaker]
--
I've talked so far here about us. What _we_ can imagine, what _we_ can express, what each of us, individually, can imagine and express.

The reality is though, as noted in the _what should I write_ question a moment ago, is that we're not usually engaged in writing software for our own amusement, we're writing for other people, and generally not for their amusement. We're writing it help in their work, or to give them access to some service - maybe book a holiday (perhaps a bad example at the moment), or to inform them they're eligible for a vaccine, or to pay a bill. Or whatever it is - you don't need me to give a list of things we use software for. You're not just programmers, you're normal people too :) You've seen software.

We've already got our own brain-computer barrier we need to cross, but now we have to understand what's in other people's brains too?  Not just the people who will use the software, but the people working with us - the other programmers, the UI designers, video artists. We have to understand what they want they all want too? And get all that into the software?
--

== !

[big]*Code is easy*

[big]*Code is hard*

[NOTE.speaker]
--
Code is easy, and code is hard, at the same time.

This is the fundamental paradox in the code we write.

We can write reams and reams of it at almost no cost. We can do unimaginable computations in fractions of a second, we chew through vast quantities of data in moments. I'm not talking about things that would astonish our grandparents, I'm taking about capabilities that would amaze ourselves of 10 years ago, five years ago even.

We can do these incredible things, just like that. It's like we have magic in our fingertips. This is ours to command. But the ease with which we can produce that code, can crunch those numbers, that open up these huge possibilities, this vast space we can explore - which is why it's so thrilling - is also why writing code can be so very, very hard.

There's a real tension there, at the very heart of what we do as _software professionals_, as programmers. We have to try and tame that paradox. It's present at all levels, but it's most manifest, most there, down there at the level of the code.

Unfortunately, and this is where I let you down, there is no trick. We aren't cutting the Gordian knot. The magic eye picture isn't going to suddenly resolve. The Mobius strip is going untwist into a nice little loop.

--

== !

[big]*There are no rules*

[NOTE.speaker]
--
There are no rules we can follow.

If there were, then software would be straightforward, everyone would be doing just fine, and none of us would have gathered here today.

This might sound like a counsel of despair. No rules? Then surely in the grim dark future there is only war? (And, honestly, some of the stories you hear might lead you to this conclusion.) While there may not be rules, we can apply some guidelines, some heuristics.

I've already suggested that we have these difference forces in play, and that we're going to be engaged in some kind of a balancing act between, well not good and evil exactly, or even between law and chaos, but between everyone with an interest in the code.

Consequently, there's a tension between these guidelines, and actually within the guidelines themselves. This is true not just in this session, but I suspect we'll see it again and again throughout the day.

Ok, let's get going
--

== !

[big]*_The code is not the important thing_*

[NOTE.speaker]
--
The people who use our software are deeply, deeply uninterested in our code. They interested in what the code does and, generally speaking for the kind of commercial software most of us are engaged in, how it makes their life easier. They are interested in, and I hate to use such a management sounding word, but it's true, in _outcomes_, and we should be too.

This is an extreme example, but I did a bit of work for a student at the university where I was working. He later told me I'd saved him 9 months of hand calculation, which meant he could submit his PhD thesis earlier than he'd ever expected. He subsequently got a research position in Hawaii and lived in a tropical paradise for the next twenty years. We can, quite genuinely change lives with an afternoon of nudging round a few Excel formulas.

As a more everyday example is the work some of my colleagues at the Ministry of Justice are doing, on preparing the court lists - the trials that are going to take place that day. The service they're in the process of deploying at the moment looks to be reducing the time it takes court staff to prepare for around 90 minutes to about 20 minutes. Now for the people who do that work, who is should be noted are generally overworked as it is, that's great. Maybe they can knock off a bit earlier - I hope so. But it also means the trials are more likely to go ahead, which is beneficial not only for perpetrators and victims of crime, but for society as whole.

The code is not important. We should focus on outcomes, on what people what to do.
--

== !

[big]*_People don't know what they want_*

[NOTE.speaker]
--

--


