= Code: Who, What, Why, Where, When
Jez Higgins, jez@jezuk.co.uk
{docdate}
:notitle:
:customcss: style/theme-tweak.css
:revealjs_theme: white
:revealjs_progress: false
:revealjs_controls: false

== !

[big]*CODE*

*Who, What, Why, Where, When* +

_Jez Higgins_

@jezhiggins@mastondon.me.uk

jez@jezuk.co.uk

[NOTE.speaker]
--
Hello again friends, I'm Jez and I'm here to talk with you about code.

* Who it's for

* What it's for

* Why we write it

and honestly, I was pleased with myself for coming up with what I thought was a snappy title, but then couldn't actually backfill enough to make what I'm going to say hit all those w-words.

Anyway, let's have a go at thinking about code. In the large and in the small, and maybe we'll address some key questions like tabs vs spaces, JavaScript vs TypeScript, and, maybe, where's the best place in Norfolk to go to the seaside.

Actually we won't, because there are no right answers to those questions. They're insoluable and, whisper it, unimportant. There are so many more soluable important things we could be thinking about instead.

If you were to say to me _write us some code, straightaway, this minute_ then sure, I can write you some code. And if I asked the same of you, all of you here, _pull out your laptop, write me some code, here in the hall now_, you'd have you hand your bag before I got to the end of the sentence, right? Right?
--

== !

[big]*Code is Easy*

[NOTE.speaker]
--
Because writing code is easy, right?

Right?

We all know how to write code, probably in more than one language, perhaps in quite a few.

So, stick your hands in your bags ... No, no, no, don't do it, because we'd all get excited and then there'd be this awkward pause, and you'd all lift your faces from the screens and look up at me here, and I'd feel even more embarrassed and nervous than I already am, with puzzled looks on your eager faces and you'd ask ...

--

== !

[big]*What should I write?*

[NOTE.speaker]
--
What should I write?

What. Should. I. Write?

Excellent question. Excellent question.

This is the key question that we, all of us here, as professional programmers, all of us in the wider programming community, should be asking.

What should I write?

Because code is hard.
--

== !

[big]*Code is Hard*

[NOTE.speaker]
--
When we write code, we're taking stuff we just think up - it comes from inside us - and communicate that into the computer and then the computer does the stuff! It's amazing! We might have forgotten, or perhaps just go to used to it, that's actually pretty incredible - we can just think things into existence. And with a little bit of practice getting that out of your brain and into the laptop, that's quite an easy process.

But! But, but, but. The very same things that make writing code easy is what makes writing hard.

We can imagine pretty much whatever we want, we can roam far and wide through the possibilities. 
--

== !

[big]*Who Is The Code For?*

[NOTE.speaker]
--
--

== !

[big]*Code Is Easy*

*and*

[big]*Code Is Hard*

[NOTE.speaker]
--
--

== !

[big]*There Are No Rules*

[NOTE.speaker]
--
--

== !

[big]*The Code Is Not Important*

[NOTE.speaker]
--
--

== !

[big]*We Don't Know*

[big]*What We Want*

[NOTE.speaker]
--
--

== !

[big]*Write Only As Much Code*

[big]*As We Need*

[NOTE.speaker]
--
--

== !

[big]*The Simplest Thing*

[big]*Might Not Be Simple*

[NOTE.speaker]
--
--

== !

[big]*Software Development*

[big]*Is Change*

[NOTE.speaker]
--
--

== !

[big]*Change One Thing*

[big]*At A Time*

[NOTE.speaker]
--
Let's say we've been asked to add some new behaviour, a new capability, _new functionality_ as the jargon has it. So we dive into the code and we have a little look around and say _yep, this will drop right in_. And that's great, and actually can be a pretty wonderful feeling.

More often though, we look at what we're working with and _if this bit was like that and we move that piece over here *THEN* it would drop it_. Well now, I would suggest, rather than one big, difficult, awkward piece of work, we have two things to do, maybe more. The first step is to _make this bit like that and move that piece of there_. The second step is to add that new behaviour, that new capability, which is going to be straightforward, because now it's just going to drop it.

Conceptually these two steps form a single action, I'm only moving one ticket across my board. But for us, as we do the work, there's one little modification, one little step, then another, and perhaps a third, and a forth.

Within each step we should be clear about what we're doing - we're modifying the shape of the code, or we're evolving the functionality of our program. These steps could be tiny - as small as extracting a single method or adding a single line of logging - but as we do the work we need to know which of these we're doing.

Improve the design or change the behaviour.
--

== !

[big]*Change The Design*

*or*

[big]*Change The Functionality*

[NOTE.speaker]
--
--

== !

[big]*The Code Is Important*

[NOTE.speaker]
--
--

== !

[big]*Make Smaller Changes*

[NOTE.speaker]
--
The software we deliver is the sum of all the modifications we've made - the integration over time all the changes we've made to our code.

When we ship, in whatever form that takes, we're gathering up all those changes, all those steps we've taken.

In order to be able to deliver the software people want, all those people involved (including us!) we talked about earlier who's needs and wants are evolving over time all the time, our code must be amenable to change. The potential within is only revealed as we change it. So we need to keep the code in good order, in a state we can easily manipulate and modify. And one of the key ways we can achieve that is by making each step we take - each refactoring, every new behaviour - as small as we can.

By keeping each step small and focussed, we keep the scope of the next step as open as we can.
--


== !

[big]*Make Smaller Changes*

[big]*No, Smaller Than That*

[NOTE.speaker]
--
--

== !

[big]**

[NOTE.speaker]
--
--
