= Code: Who, What, Why, Where, When
Jez Higgins, jez@jezuk.co.uk
{docdate}
:notitle:
:customcss: style/theme-tweak.css
:revealjs_theme: white
:revealjs_progress: false
:revealjs_controls: false

== !

[big]*CODE*

*Who, What, Why, Where, When* +

_Jez Higgins_

@jezhiggins@mastondon.me.uk

jez@jezuk.co.uk

[NOTE.speaker]
--
Hello again friends, I'm Jez and I'm here to talk with you about code.

* Who it's for

* What it's for

* Why we write it

and honestly, I was pleased with myself for coming up with what I thought was a snappy title, but then couldn't actually backfill enough to make what I'm going to say hit all those w-words.

Anyway, let's have a go at thinking about code. In the large and in the small, and maybe we'll address some key questions like tabs vs spaces, JavaScript vs TypeScript, and, maybe, where's the best place in Norfolk to go to the seaside.

Actually we won't, because there are no right answers to those questions. They're insoluable and, whisper it, unimportant. There are so many more soluable important things we could be thinking about instead.

If you were to say to me _write us some code, straightaway, this minute_ then sure, I can write you some code. And if I asked the same of you, all of you here, _pull out your laptop, write me some code, here in the hall now_, you'd have you hand your bag before I got to the end of the sentence, right? Right?
--

== !

[big]*Code is Easy*

[NOTE.speaker]
--
Because writing code is easy, right?

Right?

We all know how to write code, probably in more than one language, perhaps in quite a few.

So, stick your hands in your bags ... No, no, no, don't do it, because we'd all get excited and then there'd be this awkward pause, and you'd all lift your faces from the screens and look up at me here, and I'd feel even more embarrassed and nervous than I already am, with puzzled looks on your eager faces and you'd ask ...

--

== !

[big]*What should I write?*

[NOTE.speaker]
--
What should I write?

What. Should. I. Write?

Excellent question. Excellent question.

This is the key question that we, all of us here, as professional programmers, all of us in the wider programming community, should be asking.

What should I write?

Because code is hard.
--

== !

[big]*Code is Hard*

[NOTE.speaker]
--
When we write code, we're taking stuff we just think up - it comes from inside us - and communicate that into the computer and then the computer does the stuff! It's amazing! We might have forgotten, or perhaps just go to used to it, that's actually pretty incredible - we can just think things into existence. And with a little bit of practice getting that out of your brain and into the laptop, that's quite an easy process.

But! But, but, but. The very same things that make writing code easy is what makes writing hard.

We can imagine pretty much whatever we want, we can roam far and wide through the possibilities, it just explodes out in front of us, and then on and on and on. And there's just so much we can do ...

Capturing the piece that we want, expressing that precisely and correctly in code can be very difficult. We've got this abundance of choices and we're trying to bring it down to the one we want, the one we need. That can be difficult.

And often it feel like the way to tame those choices, to trim those branching possibilities, is to write more code - if we make that generic than it'll cover that case, but ah yes, February only has 28 days, except in an Olympic year, but don't forget the 2020/2021 Tokyo anomaly ... and then it's we're off again.

Because code is easy we can write it all day.

Because code is hard we can spend all day writing it.
--

== !

[big]*Who Is The Code For?*

[NOTE.speaker]
--
I've talked so far about us. What _we_ can imagine, what _we_ can express, what each of _us_, individually and together, can imagine and express.

In practice though, as noted in the _What should I write_ question a moment ago, is that we are not, usually, engaged in writing software for our own amusement. We're writing it for other people, and generally not for their amusement. We're writing it to help in their work, or to give them access to some service, or to make sure they get paid, or to keep the lights on - you don't need me to give you a list, you seen software.

The people who are going to use our software, who are they? Well, there's the people who want to access that service, get paid, or whatever, well, yea. But there are also the people working with us - other programmers, UI designers, maybe copywriters or video artists. If you have a support desk, what do they need? Are there operations staff that will be looking after the software. Surely there's a manager or two in the mix somewhere. Perhaps a funding agency.
--

== !

[big]*Code is for Everybody*

[NOTE.speaker]
--
All these people, and more, have an interest in the software.

So not only do we have our own thoughts, layered on those are almost infinite number of other people's thoughts too, and we somehow have to convert that into working software?

Yes. And we do. We do every day.

Because code is easy, and code is hard.
--

== !

[big]*Code Is Easy*

*and*

[big]*Code Is Hard*

[NOTE.speaker]
--
Because code is easy, and code is hard.

Code is easy and code is hard, at the same time.

This is the fundamental paradox of the medium in which we work.

We can write reams and reams of code at almost no cost. We can do incredible computations in fractions of a second, chew through vast quantities of data in momnets. I'm not talking about things that would astonish our grandparents. I'm talking about capabilities that would amaze ourselves of ten years ago, five years ago even.

We do make and do these amazing things, just like that. It's like we have magic in our fingertips. This is ours to command. But the ease with which we can produce that code, can crunch those numbers, that open up these huge potentialities, the vast multidimensional hyperspace manifolds we can explore - that's why it's so thrilling - is also why writing code can be so very, very difficult. How do we navigate this myriad of possibilities?

There's a real tension there, at the heart of what we do as programmers, as _software professionals_. We have to try and tame that paradox. It exists at all levels, but it's most manifest, most there, down at the level of the code.


--

== !

[big]*There Are No Rules*

[NOTE.speaker]
--
--

== !

[big]*The Code Is Not Important*

[NOTE.speaker]
--
--

== !

[big]*We Don't Know*

[big]*What We Want*

[NOTE.speaker]
--
--

== !

[big]*Write Only As Much Code*

[big]*As We Need*

[NOTE.speaker]
--
--

== !

[big]*The Simplest Thing*

[big]*Might Not Be Simple*

[NOTE.speaker]
--
--

== !

[big]*Software Development*

[big]*Is Change*

[NOTE.speaker]
--
--

== !

[big]*Change One Thing*

[big]*At A Time*

[NOTE.speaker]
--
Let's say we've been asked to add some new behaviour, a new capability, _new functionality_ as the jargon has it. So we dive into the code and we have a little look around and say _yep, this will drop right in_. And that's great, and actually can be a pretty wonderful feeling.

More often though, we look at what we're working with and _if this bit was like that and we move that piece over here *THEN* it would drop it_. Well now, I would suggest, rather than one big, difficult, awkward piece of work, we have two things to do, maybe more. The first step is to _make this bit like that and move that piece of there_. The second step is to add that new behaviour, that new capability, which is going to be straightforward, because now it's just going to drop it.

Conceptually these two steps form a single action, I'm only moving one ticket across my board. But for us, as we do the work, there's one little modification, one little step, then another, and perhaps a third, and a forth.

Within each step we should be clear about what we're doing - we're modifying the shape of the code, or we're evolving the functionality of our program. These steps could be tiny - as small as extracting a single method or adding a single line of logging - but as we do the work we need to know which of these we're doing.

Improve the design or change the behaviour.
--

== !

[big]*Change The Design*

*or*

[big]*Change The Functionality*

[NOTE.speaker]
--
--

== !

[big]*The Code Is Important*

[NOTE.speaker]
--
--

== !

[big]*Make Smaller Changes*

[NOTE.speaker]
--
The software we deliver is the sum of all the modifications we've made - the integration over time all the changes we've made to our code.

When we ship, in whatever form that takes, we're gathering up all those changes, all those steps we've taken.

In order to be able to deliver the software people want, all those people involved (including us!) we talked about earlier who's needs and wants are evolving over time all the time, our code must be amenable to change. The potential within is only revealed as we change it. So we need to keep the code in good order, in a state we can easily manipulate and modify. And one of the key ways we can achieve that is by making each step we take - each refactoring, every new behaviour - as small as we can.

By keeping each step small and focussed, we keep the scope of the next step as open as we can.
--


== !

[big]*Make Smaller Changes*

[big]*No, Smaller Than That*

[NOTE.speaker]
--
--

== !

[big]**

[NOTE.speaker]
--
--
